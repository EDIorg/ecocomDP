% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_data.R
\name{read_data}
\alias{read_data}
\title{Read ecocomDP data}
\usage{
read_data(
  id = NULL,
  path = NULL,
  file.type = ".rda",
  parse.datetime = TRUE,
  ...,
  globally.unique.keys = FALSE
)
}
\arguments{
\item{id}{(character) Identifier of dataset to read. Identifiers are listed in the 
"id" column of the \code{search_data()} output.  If reading multiple 
datasets, then \code{id} should be a character vector of identifiers or 
a named list containing additional arguments to filter on (for NEON data 
only; see below for arguments and examples). Older versions of ids listed in the "id" column of the \code{search_data()} output are supported, but a warning is issued.}

\item{path}{(character) Path to the directory in which the data will be written.}

\item{file.type}{(character) Type of file to save the data to. Options are: ".rda", 
".csv".}

\item{parse.datetime}{(logical) Attempt to parse datetime character strings through an algorithm. For EDI, the algorithm looks at the EML formatString value and calls \code{lubridate::parse_date_time()} with the appropriate \code{orders}. For NEON, the algorithm iterates through permutations of \code{ymd HMS} orders. Failed attempts will return a warning. Default is \code{TRUE}. No attempt is made at using time zones if included (these are dropped before parsing).}

\item{globally.unique.keys}{(logical) Whether to create globally unique primary keys (and associated
foreign keys). Reading multiple datasets raises the issue of referential 
integrity across datasets. If TRUE, \code{id} is appended to each 
table's primary key and associated foreign key. Defaults to FALSE.}

\item{site}{(character; NEON data only) A character vector of site codes to filter 
data on. Sites are listed in the "sites" column of the 
\code{search_data()} output. Defaults to "all", meaning all sites.}

\item{startdate}{(character; NEON data only) Start date to filter on in the form YYYY-MM. 
Defaults to NA, meaning all available dates.}

\item{enddate}{(character; NEON data only) End date to filter on in the form YYYY-MM. 
Defaults to NA, meaning all available dates.}

\item{package}{(character; NEON data only) Either 'basic' or 'expanded', indicating 
which data package to download. Defaults to basic.}

\item{check.size}{(logical; NEON data only) Should the user approve the total file size 
before downloading? Defaults to FALSE.}

\item{nCores}{(integer; NEON data only) The number of cores to parallelize the 
stacking procedure. Defaults to 1.}

\item{forceParallel}{(logical; NEON data only) If the data volume to be processed does not 
meet minimum requirements to run in parallel, this overrides. Defaults 
to FALSE.}

\item{token}{(character; NEON data only) User specific API token (generated within 
neon.datascience user accounts)}

\item{neon.data.save.dir}{(character) Directory to save NEON source data that has been downloaded 
via \code{neonUtilities::loadByProduct()}}

\item{neon.data.read.path}{(character) Path to read in an RDS file of 'stacked NEON data' from 
\code{neonUtilities::loadByProduct()}}

\item{neon.data.list}{(list) A list of stacked NEON data tables to be mapped to ecocomDP. 
Must match the chosen mapping method in 'id'}
}
\value{
(list) A named list of \code{id}, each including: 
    \item{metadata}{A list of information about the data.}
    \item{tables}{A list of data.frames following the ecocomDP format 
    (\url{https://github.com/EDIorg/ecocomDP/blob/master/documentation/model/table_visualization.md})}
    \item{validation_issues}{If the dataset fails any validation checks, 
    then they are listed here as a vector of character strings describing 
    each issue.}
}
\description{
Read ecocomDP data
}
\details{
Validation checks are applied to each dataset ensuring they comply with 
    the ecocomDP. A warning is issued when any validation check fails 
    (please report these to \url{https://github.com/EDIorg/ecocomDP/issues}). 
    All datasets are returned, even if they fail validation.
    
    Column classes are coerced to those defined in the ecocomDP 
    specification.
}
\examples{
# Read a dataset
d <- read_data("edi.193.3")
d <- read_data("neon.ecocomdp.20166.001.001")

# Read a NEON dataset with filters
d <- read_data(
  id = "neon.ecocomdp.20166.001.001", 
  site = c("MAYF", "PRIN"), 
  startdate = "2016-01", 
  enddate = "2018-11")

# Read multiple datasets from different sources
d <- read_data(c("edi.193.3", "neon.ecocomdp.20166.001.001"))

# Read multiple datasets from EDI and NEON with NEON filters
d <- read_data(
  id = list(
    edi.193.3 = NULL,
    neon.ecocomdp.20166.001.001 = list(
      site = c("MAYF", "PRIN"),
      startdate = "2016-01",
      enddate = "2018-11")),
  check.size = TRUE,
  nCores = 2,
  forceParallel = FALSE)
  
}
